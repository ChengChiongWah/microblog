1.Introduction
  The tutorial assumes that you have:
   .a free heroku account
   .python installed
   .setuptools and pip
   .virtualenv
   .Postgres (if running the app locally)
2. Set up
  In this step you will install the Heroku Toolbelt.This provides you access to the Heroku Command Line Interface (CLI), which can be used for managing and scaling your applications and add-ons. A key part of the toolbelt is the :heroku local command,which can help in running your applications locally.Once installed, you can use the heroku command from your command shell.Log in using the email address and password you used when creating your Heroku account:
$heroku login
3.Prepare the app
  In this step, you will prepare a simple application that can be deployed.Execute the following commands to clone the sample application:
$git clone https://..........
$cd python-ge.....
You now have a functioning git repository that contains a simple application as well as a requirements.txt,file, which is used by Python’s dependency manager, Pip.
4.Deploy the app
  In this step you will deploy the app to Heroku.
  Create an app on Heroku, which prepares Heroku to receive your source code:
$heroku create
......
.........
  When you create an app, a git remote (called heroku) is also created and associated with your local git repository.Heroku generates a random name (in this case lit-bastion-5032) for your app, or you can pass a parameter to specify your own app name.
  Now deploy your code:
$git push heroku master
.........
...........
  While the deployment is happening, you may see a syntax error during the install for gunicorn about invalid syntax for the line yield from self.wsgi.close(). That error can be ignored.
  The application is now deployed. Ensure that at least one instance of the app is running:
$heroku ps:scale web=1
  Now visit the app at the URL generated by its app name. As a handy shortcut, you can open the website as follows:
$heroku open
5.View logs
  Heroku treats logs as streams of time-ordered events aggregated from the output streams of all your app and Heroku components, providing a single channel for all of the events.
  View information about your running app using one of the logging commands, heroku logs:
$heroku logs --tail
  Visit your application in the browser again, and you’ll see another log message generated.
  Press Control+C to stop streaming the logs.
6.Define a Procfile
  Use a Procfile, a text file in the root directory of your application, to explicitly declare what command should be executed to start your app.
  The Procfile in the example app you deployed looks like this:
 web: gunicorn gettingstarted.wsgi --log-file - 
  This declares a single process type, web, and the command needed to run it. The name web is important here. It declares that this process type will be attached to the HTTP routing stack of Heroku, and receive web traffic when deployed.
  Procfiles can contain additional process types. For example, you might declare one for a background worker process that processes items off of a queue.
7.Scale the app
  Right now, your app is running on a single web dyno. Think of a dyno as a lightweight container that runs the command specified in the Procfile.
  You can check how many dynos are running using the ps command:
$heroku ps
....
........
  By default, your app is deployed on a free dyno. Free dynos will sleep after a half hour of inactivity and they can be active (receiving traffic) for no more than 18 hours a day before going to sleep. If a free dyno is sleeping, and it hasn’t exceeded the 18 hours, any web request will wake it. This causes a delay of a few seconds for the first request upon waking. Subsequent requests will perform normally.
  To avoid dyno sleeping, you can upgrade to a hobby or professional dyno type as described in the Dyno Types article. For example, if you migrate your app to a professional dyno, you can easily scale it by running a command telling Heroku to execute a specific number of dynos, each running your web process type.
  For abuse prevention, scaling the application may require account verification. If your account has not been verified, you will be directed to visit the verification site.
8.Declare app dependencies
  Heroku recognizes an app as a Python app by the existence of a requirements.txt file in the root directory. For your own apps, you can create one by running pip freeze.
  The demo app you deployed already has a requirements.txt, and it looks something like this:
 Django ==1.8
 wsgiref==0.1.2
  The requirements.txt file lists the app dependencies together with their versions. When an app is deployed, Heroku reads this file and installs the appropriate Python dependencies using the pip install -r requirements.txt --allow-all-external command.
  To do this locally, use the virtualenv associated with the app:
$virtualenv venv
  If you are using Windows,run this command:
$ venv\Scripts\activate.bat
If you are not using Windows, run this command:
$source venv/bin/activate
  Now run this command in your local directory to install the dependencies, preparing your system for running the app locally:
$pip install -r requirements.txt --allow-all-external
  Once dependencies are installed, you will be ready to run your app locally.
9.Run the app locally
  The app is almost ready to start locally. Django uses local assets, so first, you’ll need to run collectstatic: 
$python manage.py collectstatic
  Respond with “yes”.
  Now start your application locally using heroku local, which was installed as part of the Toolbelt:
$heroku local web
  Just like Heroku, heroku local examines the Procfile to determine what to run.
  Your app will now be running at localhost:5000. Test that it’s working with curl or a web browser, then Ctrl-C to exit.
  heroku local doesn’t just run your app - it also sets “config vars”, something you’ll encounter in a later tutorial.
10.Push local changes
  In this step you’ll learn how to propagate a local change to the application through to Heroku. As an example, you’ll modify the application to add an additional dependency and the code to use it.
  Modify requirements.txt to include a dependency for requests:
requests==2.3.0
  Your final requirements.txt should look something like this:
Django==1.8
....
requests==2.3.0
  Modify hello/views.py so that it imports the requests module at the start:
import requests
  Now modify the index method to make use of the module. Try replacing the current index method with the following code:
def index(request):
    r = requests.get('http://httpbin.org/status/418')
    print r.text
    return HttpResponse('<pre>' + r.text + '</pre>')
  Now test locally:
$pip install -r requirements.txt --allow-all-external
$heroku local
Visiting your application at http://localhost:5000/. You should now see the output of fetching http://httpbin.org/status/418, which is a lovely teapot:
-=[ teapot ]=-
...
.....
  Now deploy. Almost every deploy to Heroku follows this same pattern.      First, add the modified files to the local git repository:
$git add .
  Now commit the changes to the respository
$git commit -m "Demo"
  Now deploy, just as you did previously:
$git push heroku master
  Finaly,check that everythings is working:
$heroku open
11.Provision add-ons
  Add-ons are third-party cloud services that provide out-of-the-box additional services for your application, from persistence through logging to monitoring and more.
  By default, Heroku stores 1500 lines of logs from your application. However, it makes the full log stream available as a service - and several add-on providers have written logging services that provide things such as log persistence, search, and email and SMS alerts when certain conditions are met.
  Provision the papertrail logging add-on:
$heroku addons:create papertrail
..
....
  To help with abuse prevention, provisioning an add-on may require account verification. If your account has not been verified, you will be directed to visit the verification site.
  The add-on is now deployed and configured for your application. You can list add-ons for your app like so:
$heroku addons
  To see this particular add-on in action, visit your application’s Heroku URL a few times. Each visit will generate more log messages, which should now get routed to the papertrail add-on. Visit the papertrail console to see the log messages:
$heroku addons:open papertrail
A console will open up, showing the latest log events, and providing you with an interface to search and set up alerts:
.......
...........
12.Start a console
  You can run a command, typically scripts and applications that are part of your app, in a one-off dyno using the heroku run command. It can also be used to launch a REPL process attached to your local terminal for experimenting in your app’s environment:
$heroku run python manager.py shell
  If you receive an error, Error connecting to process, then you may need to configure your firewall.
  The Python shell is running in the context of your app and all its dependencies. From here you can import some of your application files. For example, you will be be able to run the following:
>>>import requests
>>>print ....
To get a real feel for how dynos work, you can create another one-off dyno and run the bash command, which opens up a shell on that dyno. You can then execute commands there. Each dyno has its own ephemeral filespace, populated with your app and its dependencies - once the command completes (in this case, bash), the dyno is removed.
$heroku run bash
....
~$ls
....
~$exit
exit
  Don’t forget to type exit to exit the shell and terminate the dyno.
13.Define config vars 
  Heroku lets you externalise configuration - storing data such as encryption keys or external resource addresses in config vars.
  At runtime, config vars are exposed as environment variables to the application.
  Edit hello/views.py. At the beginning, add a line to import the os module:
import os
  Now modify the index method so that it repeats an action depending on the value of the TIMES environment variable:
def index(request):
    times = int(os.environ.get('TIMES',3))
    return HttpResponse('Hello! ' * times)
heroku local will automatically set up the environment based on the contents of the .env file in your local directory. Edit the .env file to add:
TIMEs=2
  If you run the app with heroku local, you’ll see two “Hello!”’s.
  To set the config var on Heroku, execute the following:
$heroku config:set TIMES=2
  View the config vars that are set using heroku config:
$heroku config
  Deploy your changed application to Heroku to see this in action.
14.Provision a database
  The add-on marketplace has a large number of data stores, from Redis and MongoDB providers, to Postgres and MySQL. In this step you will learn about the free Heroku Postgres add-on that was automatically provisioned when your app was deployed.
  A database is an add-on, and so you can find out a little more about the database provisioned for your app using the addons command in the CLI:
$heroku addons
.....
.......
  Listing the config vars for your app will display the URL that your app is using to connect to the database, DATABASE_URL:
$heroku config
......
........
  Heroku also provides a pg command that shows a lot more:
$heroku pg
......
.............
  This indicates I have a hobby database (free), running Postgres 9.3.3, with a single row of data.
  The example app you deployed already has database functionality, which you should be able to reach by visiting your app’s URL and appending /db. For example, if your app was deployed to https://wonderful-app-287.herokuapp.com/ then visit https://wonderful-app-287.herokuapp.com/db.
  Accessing it will yield an error though, because while the database is configured, the tables have not been created. Run the standard Django manage.py migrate to create the tables.
  Accessing it will yield an error though, because while the database is configured, the tables have not been created. Run the standard Django manage.py migrate to create the tables.
$heroku run python manage.py migrate
  If you see a message that says, “You just installed Django’s auth system, which means you don’t have any superusers defined. Would you like to create one now?”, type no.
  Now access the /db route again and you’ll see a simple page update every time you access it:
Page View Report
....
...........
  The code to access the database is straightforward, and makes use of a simple Django model called Greetings that you can find in hello/models.py.
  The only configuration that’s necessary can be found in gettingstarted/settings.py, which sets up the database based on the environment variable DATABASE_URL:
#Parse database configuration from $DATABASE_URL
import dj_database_url
...
DATABASES['default'] = dj............
  Whenever you visit the /db route of your app, the following method in the hello/views.py file is invoked which creates a new Greeting and then renders all the existing Greetings:
  def db(request):
    greeting = Greeting()
    greeting.save()
    greetings = Greeting.objects.all()
    return render(request, 'db.html', {'greetings': greetings})
  Assuming that you have Postgres installed locally, use the heroku pg:psql command to connect to the remote database and see all the rows:
$heroku pg:psql
........
..............

